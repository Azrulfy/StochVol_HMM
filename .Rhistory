cc <- sv_loglik(theta_mle, y,eta_sim, u_sim, alpha_up_0, alpha_wt_0)
loglik <- cc[[1]]
alpha <- cc[[2]]
return(list(loglik = loglik,
theta_mle = theta_mle,
alpha_up_pr = alpha))
}
sv_fit <- function(y, theta, P, estimate) {
T <- length(y)
alpha_up_0 <- rnorm(P, 0,1)
alpha_wt_0 <- rep(1/P,P)
eta_sim <- rnorm(P*T, 0,1)
eta_sim <- matrix(eta_sim, nrow=P, ncol=T)
u_sim <- runif(P*T, 0,1)
u_sim <- matrix(u_sim, P, T)
for (t in c(1:T)) {u_sim[,t] <- sort( u_sim[,t] )}
if(estimate==1) {
print('estimating...')
# set optimization parameters
lb <- rep(0, length(theta))+0.001;
ub <- rep(1, length(theta))-2*exp(-10);
obj <- function(x){ return( sv_loglik(x,y, eta_sim, u_sim, alpha_up_0, alpha_wt_0)[[1]] ) }
# run box-constrained optimization
param <- nlminb( theta, obj, lower=lb, upper=ub )
theta_mle <- param$par
theta_se <- c()
## !! To check how to compute the hessian
#theta_se =diag(sqrt(inv(HESSIAN)));
print('... done!')
} else {
theta_mle <- c()
theta_se <- c()
}
# compute log-liklihood of MLE parameters
cc <- sv_loglik(theta_mle, y,eta_sim, u_sim, alpha_up_0, alpha_wt_0)
loglik <- cc[[1]]
alpha <- cc[[2]]
return(list(loglik = loglik,
theta_mle = theta_mle,
alpha_up_pr = alpha))
}
library(nloptr)
theta <- c(0.05, 0.98, 0.02)
sim_df <- sv_sim(theta, 1000)
y <- sim_df$y
P <- 200
values <- sv_fit(y,theta,P,1)
sv_loglik <- function(theta, y, eta_sim, u_sim, alpha_up, alpha_wt) {
T <- length(y)
P <- length(alpha_up)
const <- theta[1]
phi <- theta[2]
tau2 <- theta[3]
alpha_up_pr <- matrix(0, nrow=T, ncol=4)
loglik <- 0
for (t in 1:T) {
alpha_pr <- const + phi*alpha_up + sqrt(tau2)*eta_sim[,t]
lik <- dnorm( y[t]*rep(1,P) , rep(0,P) , exp(alpha_pr/2))
log_mean_lik <- tryCatch(log(mean(lik)), error=function(e)(NA))
if (is.na( log_mean_lik )) {
print(paste('problem at ',as.character(t),as.character(theta)))
loglik <- Inf
alpha_up_pr <- NA
break
} else {
loglik <- loglik - log_mean_lik
# update
alpha_wt <- lik
alpha_up <- csir(alpha_pr,alpha_wt,u_sim[,t])
# quantiles
alpha_up_pr[t,1] <- mean( alpha_up )
alpha_up_pr[t,2] <- mean( alpha_pr )
alpha_up_pr[t,c(3,4)] <- quantile( alpha_pr ,c(0.05,0.95))
}
}
loglik <- loglik/T
return(list(loglik = loglik, alpha_up_pr = alpha_up_pr))
}
sv_fit <- function(y, theta, P, estimate) {
T <- length(y)
alpha_up_0 <- rnorm(P, 0,1)
alpha_wt_0 <- rep(1/P,P)
eta_sim <- rnorm(P*T, 0,1)
eta_sim <- matrix(eta_sim, nrow=P, ncol=T)
u_sim <- runif(P*T, 0,1)
u_sim <- matrix(u_sim, P, T)
for (t in c(1:T)) {u_sim[,t] <- sort( u_sim[,t] )}
if(estimate==1) {
print('estimating...')
# set optimization parameters
lb <- rep(0, length(theta))+0.001;
ub <- rep(1, length(theta))-2*exp(-10);
obj <- function(x){ return( sv_loglik(x, y, eta_sim, u_sim, alpha_up_0, alpha_wt_0)$loglik ) }
# run box-constrained optimization
param <- nlminb( theta, obj, lower=lb, upper=ub )
theta_mle <- param$par
theta_se <- c()
## !! To check how to compute the hessian
#theta_se =diag(sqrt(inv(HESSIAN)));
print('... done!')
} else {
theta_mle <- c()
theta_se <- c()
}
# compute log-liklihood of MLE parameters
ll <- sv_loglik(theta_mle, y, eta_sim, u_sim, alpha_up_0, alpha_wt_0)
return(list(loglik = - ll$loglik,
theta_mle = theta_mle,
alpha_up_pr = ll$alpha_up_pr))
}
theta <- c(0.05, 0.98, 0.02)
sim_df <- sv_sim(theta, 1000)
y <- sim_df$y
P <- 200
values <- sv_fit(y,theta,P,1)
estimate <- 1
theta <- c(0.05, 0.98, 0.02)
sim_df <- sv_sim(theta, 1000)
y <- sim_df$y
P <- 200
T <- length(y)
alpha_up_0 <- rnorm(P, 0,1)
alpha_wt_0 <- rep(1/P,P)
eta_sim <- rnorm(P*T, 0,1)
eta_sim <- matrix(eta_sim, nrow=P, ncol=T)
u_sim <- runif(P*T, 0,1)
u_sim <- matrix(u_sim, P, T)
for (t in c(1:T)) {u_sim[,t] <- sort( u_sim[,t] )}
lb <- rep(0, length(theta))+0.001;
ub <- rep(1, length(theta))-2*exp(-10);
obj <- function(x){ return( sv_loglik(x, y, eta_sim, u_sim, alpha_up_0, alpha_wt_0)$loglik ) }
param <- nlminb( theta, obj, lower=lb, upper=ub )
theta_mle <- param$par
ll <- sv_loglik(theta_mle, y, eta_sim, u_sim, alpha_up_0, alpha_wt_0)
sv_loglik2 <- function(theta, y, eta_sim, u_sim, alpha_up, alpha_wt) {
T <- length(y)
P <- length(alpha_up)
const <- theta[1]
phi <- theta[2]
tau2 <- theta[3]
loglik <- 0
for (t in 1:T) {
alpha_pr <- const + phi*alpha_up + sqrt(tau2)*eta_sim[,t]
lik <- dnorm( y[t]*rep(1,P) , rep(0,P) , exp(alpha_pr/2))
log_mean_lik <- tryCatch(log(mean(lik)), error=function(e)(NA))
if (is.na( log_mean_lik )) {
print(paste('problem at ',as.character(t),as.character(theta)))
loglik <- Inf
break
} else {
loglik <- loglik - log_mean_lik
}
}
loglik <- loglik/T
return(list(loglik = loglik))
}
obj <- function(x){ return( sv_loglik2(x, y, eta_sim, u_sim, alpha_up_0, alpha_wt_0)$loglik ) }
param <- nlminb( theta, obj, lower=lb, upper=ub )
sv_loglik2 <- function(theta, y, eta_sim, u_sim, alpha_up, alpha_wt) {
T <- length(y)
P <- length(alpha_up)
const <- theta[1]
phi <- theta[2]
tau2 <- theta[3]
loglik <- 0
for (t in 1:T) {
alpha_pr <- const + phi*alpha_up + sqrt(tau2)*eta_sim[,t]
lik <- dnorm( y[t]*rep(1,P) , rep(0,P) , exp(alpha_pr/2))
log_mean_lik <- tryCatch(log(mean(lik)), error=function(e)(NA))
if (is.na( log_mean_lik )) {
print(paste('problem at ',as.character(t),as.character(theta)))
loglik <- Inf
break
} else {
loglik <- loglik - log_mean_lik
alpha_wt <- lik
alpha_up <- csir(alpha_pr,alpha_wt,u_sim[,t])
}
}
loglik <- loglik/T
return(list(loglik = loglik))
}
obj <- function(x){ return( sv_loglik2(x, y, eta_sim, u_sim, alpha_up_0, alpha_wt_0)$loglik ) }
param <- nlminb( theta, obj, lower=lb, upper=ub )
values$alpha_up_pr
theta <- c(0.05, 0.98, 0.02)
sim_df <- sv_sim(theta, 1000)
y <- sim_df$y
P <- 200
T <- length(y)
alpha_up_0 <- rnorm(P, 0,1)
alpha_wt_0 <- rep(1/P,P)
eta_sim <- rnorm(P*T, 0,1)
eta_sim <- matrix(eta_sim, nrow=P, ncol=T)
u_sim <- runif(P*T, 0,1)
u_sim <- matrix(u_sim, P, T)
for (t in c(1:T)) {u_sim[,t] <- sort( u_sim[,t] )}
lb <- rep(0,length(theta)) + 0.001;
ub <- rep(1,length(theta)) - 2*exp(-10);
obj <- function(x){ return( sv_loglik(x, y, eta_sim, u_sim, alpha_up_0, alpha_wt_0)$loglik ) }
param <- nlm( theta, obj, hessian = TRUE)
param <- nlm( obj, theta, hessian = TRUE)
param <- nlm( obj, theta, hessian = TRUE)
param <- nlm( obj, theta, hessian = TRUE)
sv_loglik <- function(theta, y, eta_sim, u_sim, alpha_up, alpha_wt) {
T <- length(y)
P <- length(alpha_up)
const <- theta[1]
phi <- theta[2]
tau2 <- theta[3]
alpha_up_pr <- matrix(0, nrow=T, ncol=4)
loglik <- 0
for (t in 1:T) {
alpha_pr <- const + phi*alpha_up + sqrt(tau2)*eta_sim[,t]
lik <- dnorm( y[t]*rep(1,P) , rep(0,P) , exp(alpha_pr/2))
print(lik)
log_mean_lik <- tryCatch(log(mean(lik)), error=function(e)(Inf))
if (is.na( log_mean_lik )) {
print(paste('problem at ',as.character(t),as.character(theta)))
loglik <- Inf
alpha_up_pr <- NA
break
} else {
loglik <- loglik - log_mean_lik
# update
alpha_wt <- lik
alpha_up <- csir(alpha_pr, alpha_wt, u_sim[,t])
# quantiles
alpha_up_pr[t,1] <- mean( alpha_up )
alpha_up_pr[t,2] <- mean( alpha_pr )
alpha_up_pr[t,c(3,4)] <- quantile( alpha_pr ,c(0.05,0.95))
}
}
loglik <- loglik/T
return(list(loglik = loglik, alpha_up_pr = alpha_up_pr))
}
param <- nlm( obj, theta, hessian = TRUE)
sv_loglik <- function(theta, y, eta_sim, u_sim, alpha_up, alpha_wt) {
T <- length(y)
P <- length(alpha_up)
const <- theta[1]
phi <- theta[2]
tau2 <- theta[3]
alpha_up_pr <- matrix(0, nrow=T, ncol=4)
loglik <- 0
for (t in 1:T) {
alpha_pr <- const + phi*alpha_up + sqrt(tau2)*eta_sim[,t]
lik <- dnorm( y[t]*rep(1,P) , rep(0,P) , exp(alpha_pr/2))
#print(lik)
log_mean_lik <- tryCatch(log(mean(lik)), error=function(e)(-Inf))
if (is.na( log_mean_lik )) {
print(paste('problem at ',as.character(t),as.character(theta)))
loglik <- Inf
alpha_up_pr <- NA
break
} else {
loglik <- loglik - log_mean_lik
# update
alpha_wt <- lik
alpha_up <- csir(alpha_pr, alpha_wt, u_sim[,t])
# quantiles
alpha_up_pr[t,1] <- mean( alpha_up )
alpha_up_pr[t,2] <- mean( alpha_pr )
alpha_up_pr[t,c(3,4)] <- quantile( alpha_pr ,c(0.05,0.95))
}
}
loglik <- loglik/T
return(list(loglik = loglik, alpha_up_pr = alpha_up_pr))
}
param <- nlm( obj, theta, hessian = TRUE)
sv_loglik <- function(theta, y, eta_sim, u_sim, alpha_up, alpha_wt) {
T <- length(y)
P <- length(alpha_up)
const <- theta[1]
phi <- theta[2]
tau2 <- theta[3]
alpha_up_pr <- matrix(0, nrow=T, ncol=4)
loglik <- 0
for (t in 1:T) {
alpha_pr <- const + phi*alpha_up + sqrt(tau2)*eta_sim[,t]
lik <- dnorm( y[t]*rep(1,P) , rep(0,P) , exp(alpha_pr/2))
log_mean_lik <- tryCatch(log(mean(lik)), error=function(e)(NA))
print(log_mean_lik)
if (is.na( log_mean_lik )) {
print(paste('problem at ',as.character(t),as.character(theta)))
loglik <- Inf
alpha_up_pr <- NA
break
} else {
loglik <- loglik - log_mean_lik
# update
alpha_wt <- lik
alpha_up <- csir(alpha_pr, alpha_wt, u_sim[,t])
# quantiles
alpha_up_pr[t,1] <- mean( alpha_up )
alpha_up_pr[t,2] <- mean( alpha_pr )
alpha_up_pr[t,c(3,4)] <- quantile( alpha_pr ,c(0.05,0.95))
}
}
loglik <- loglik/T
return(list(loglik = loglik, alpha_up_pr = alpha_up_pr))
}
param <- nlm( obj, theta, hessian = TRUE)
sv_loglik <- function(theta, y, eta_sim, u_sim, alpha_up, alpha_wt) {
T <- length(y)
P <- length(alpha_up)
const <- theta[1]
phi <- theta[2]
tau2 <- theta[3]
alpha_up_pr <- matrix(0, nrow=T, ncol=4)
loglik <- 0
for (t in 1:T) {
alpha_pr <- const + phi*alpha_up + sqrt(tau2)*eta_sim[,t]
lik <- dnorm( y[t]*rep(1,P) , rep(0,P) , exp(alpha_pr/2))
log_mean_lik <- tryCatch(log(mean(lik)), error=function(e)(NA))
print(log_mean_lik)
#if (is.na( log_mean_lik )) {
if (log_mean_lik == -Inf) {
print(paste('problem at ',as.character(t),as.character(theta)))
loglik <- Inf
alpha_up_pr <- NA
break
} else {
loglik <- loglik - log_mean_lik
# update
alpha_wt <- lik
alpha_up <- csir(alpha_pr, alpha_wt, u_sim[,t])
# quantiles
alpha_up_pr[t,1] <- mean( alpha_up )
alpha_up_pr[t,2] <- mean( alpha_pr )
alpha_up_pr[t,c(3,4)] <- quantile( alpha_pr ,c(0.05,0.95))
}
}
loglik <- loglik/T
return(list(loglik = loglik, alpha_up_pr = alpha_up_pr))
}
param <- nlm( obj, theta, hessian = TRUE)
sv_loglik <- function(theta, y, eta_sim, u_sim, alpha_up, alpha_wt) {
T <- length(y)
P <- length(alpha_up)
const <- theta[1]
phi <- theta[2]
tau2 <- theta[3]
alpha_up_pr <- matrix(0, nrow=T, ncol=4)
loglik <- 0
for (t in 1:T) {
alpha_pr <- const + phi*alpha_up + sqrt(tau2)*eta_sim[,t]
lik <- dnorm( y[t]*rep(1,P) , rep(0,P) , exp(alpha_pr/2))
log_mean_lik <- tryCatch(log(mean(lik)), error=function(e)(-Inf))
print(log_mean_lik)
#if (is.na( log_mean_lik )) {
if (log_mean_lik == -Inf) {
print(paste('problem at ',as.character(t),as.character(theta)))
loglik <- Inf
alpha_up_pr <- NA
break
} else {
loglik <- loglik - log_mean_lik
# update
alpha_wt <- lik
alpha_up <- csir(alpha_pr, alpha_wt, u_sim[,t])
# quantiles
alpha_up_pr[t,1] <- mean( alpha_up )
alpha_up_pr[t,2] <- mean( alpha_pr )
alpha_up_pr[t,c(3,4)] <- quantile( alpha_pr ,c(0.05,0.95))
}
}
loglik <- loglik/T
return(list(loglik = loglik, alpha_up_pr = alpha_up_pr))
}
param <- nlminb( theta, obj, lower=lb, upper=ub )
?nlminb
h <- hessian(obj, theta_mle)
install.packages("numDeriv")
h <- hessian(obj, theta_mle)
library(numDeriv)
h <- hessian(obj, theta_mle)
diag(sqrt(inv(h)))
diag(sqrt(solve(h)))
inv(h)
solve(h)
h
param <- optim( theta, obj, lower=lb, upper=ub, hessian=TRUE )
sv_loglik <- function(theta, y, eta_sim, u_sim, alpha_up, alpha_wt) {
T <- length(y)
P <- length(alpha_up)
const <- theta[1]
phi <- theta[2]
tau2 <- theta[3]
alpha_up_pr <- matrix(0, nrow=T, ncol=4)
loglik <- 0
for (t in 1:T) {
alpha_pr <- const + phi*alpha_up + sqrt(tau2)*eta_sim[,t]
lik <- dnorm( y[t]*rep(1,P) , rep(0,P) , exp(alpha_pr/2))
log_mean_lik <- tryCatch(log(mean(lik)), error=function(e)(-Inf))
#print(log_mean_lik)
#if (is.na( log_mean_lik )) {
if (log_mean_lik == -Inf) {
print(paste('problem at ',as.character(t),as.character(theta)))
loglik <- Inf
alpha_up_pr <- NA
break
} else {
loglik <- loglik - log_mean_lik
# update
alpha_wt <- lik
alpha_up <- csir(alpha_pr, alpha_wt, u_sim[,t])
# quantiles
alpha_up_pr[t,1] <- mean( alpha_up )
alpha_up_pr[t,2] <- mean( alpha_pr )
alpha_up_pr[t,c(3,4)] <- quantile( alpha_pr ,c(0.05,0.95))
}
}
loglik <- loglik/T
return(list(loglik = loglik, alpha_up_pr = alpha_up_pr))
}
param <- optim( theta, obj, method='L-BFGS-B', lower=lb, upper=ub, hessian=TRUE )
theta_se =diag(sqrt(solve(param$hessian)));
param$hessian
solve(param$hessian)
sqrt(solve(param$hessian))
theta_se <- diag(sqrt(solve(param$hessian)))
sv_fit <- function(y, theta, P, estimate) {
T <- length(y)
alpha_up_0 <- rnorm(P, 0,1)
alpha_wt_0 <- rep(1/P,P)
eta_sim <- rnorm(P*T, 0,1)
eta_sim <- matrix(eta_sim, nrow=P, ncol=T)
u_sim <- runif(P*T, 0,1)
u_sim <- matrix(u_sim, P, T)
for (t in c(1:T)) {u_sim[,t] <- sort( u_sim[,t] )}
if(estimate==1) {
print('estimating...')
# set optimization parameters
lb <- rep(0,length(theta)) + 0.001;
ub <- rep(1,length(theta)) - 2*exp(-10);
obj <- function(x){ return( sv_loglik(x, y, eta_sim, u_sim, alpha_up_0, alpha_wt_0)$loglik ) }
# run box-constrained optimization
#param <- nlminb( theta, obj, lower=lb, upper=ub )
param <- optim( theta, obj, method='L-BFGS-B', lower=lb, upper=ub, hessian=TRUE )
theta_mle <- param$par
theta_se <- diag(sqrt(solve(param$hessian)))
print('... done!')
} else {
theta_mle <- c()
theta_se <- c()
}
# compute log-liklihood (quantiles) of MLE parameters
ll <- sv_loglik(theta_mle, y, eta_sim, u_sim, alpha_up_0, alpha_wt_0)
return(list(loglik      = - ll$loglik,
theta_mle   = theta_mle,
theta_se    = theta_se,
alpha_up_pr = ll$alpha_up_pr))
}
start <- proc.time()
theta <- c(0.05, 0.98, 0.02)
sim_df <- sv_sim(theta, 1000)
y <- sim_df$y
P <- 200
diff <- proc.time() - start
diff
start <- proc.time()
values <- sv_fit(y,theta,P,1)
diff <- proc.time() - start
diff
sv_fit <- function(y, theta, P, estimate) {
T <- length(y)
alpha_up_0 <- rnorm(P, 0,1)
alpha_wt_0 <- rep(1/P,P)
eta_sim <- rnorm(P*T, 0,1)
eta_sim <- matrix(eta_sim, nrow=P, ncol=T)
u_sim <- runif(P*T, 0,1)
u_sim <- matrix(u_sim, P, T)
for (t in c(1:T)) {u_sim[,t] <- sort( u_sim[,t] )}
if(estimate==1) {
print('estimating...')
# set optimization parameters
lb <- rep(0,length(theta)) + 0.001;
ub <- rep(1,length(theta)) - 2*exp(-10);
obj <- function(x){ return( sv_loglik(x, y, eta_sim, u_sim, alpha_up_0, alpha_wt_0)$loglik ) }
# run box-constrained optimization
param <- nlminb( theta, obj, lower=lb, upper=ub )
#param <- optim( theta, obj, method='L-BFGS-B', lower=lb, upper=ub, hessian=TRUE )
theta_mle <- param$par
#theta_se <- diag(sqrt(solve(param$hessian)))
theta_se <- c()
print('... done!')
} else {
theta_mle <- c()
theta_se <- c()
}
# compute log-liklihood (quantiles) of MLE parameters
ll <- sv_loglik(theta_mle, y, eta_sim, u_sim, alpha_up_0, alpha_wt_0)
return(list(loglik      = - ll$loglik,
theta_mle   = theta_mle,
theta_se    = theta_se,
alpha_up_pr = ll$alpha_up_pr))
}
theta <- c(0.05, 0.98, 0.02)
sim_df <- sv_sim(theta, 1000)
y <- sim_df$y
P <- 200
start <- proc.time()
values <- sv_fit(y,theta,P,1)
diff <- proc.time() - start
theta <- c(0.05, 0.98, 0.02)
sim_df <- sv_sim(theta, 1000)
y <- sim_df$y
P <- 200
start <- proc.time()
values <- sv_fit(y,theta,P,1)
diff <- proc.time() - start
